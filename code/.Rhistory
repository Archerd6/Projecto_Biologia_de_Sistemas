genesexpresados <- rnaseq[pos.table,]
length(which(top.table$logFC<5))
length(which(top.table$logFC<2))
length(which(top.table$logFC<1.2))
length(which(top.table$logFC>1.2))
pos.table <- which(top.table$logFC > 18 & top.table$P.Value<0.05) #Posicion de los genes buenos?
genesexpresados <- rnaseq[pos.table,]
pos.table <- which(top.table$logFC > 18) #Posicion de los genes buenos?
genesexpresados <- rnaseq[pos.table,]
genesexpresados <- rnaseq[pos.table,]
pos.table <- which(top.table$logFC > 1.2) #Posicion de los genes buenos?
genesexpresados <- rnaseq[pos.table,]
length(which(top.table$logFC>1.2 & top.table$P.Value<0.05)))
length(which(top.table$logFC>1.2 & top.table$P.Value<0.05))
head(top.table, 10)
length(which(top.table$logFC>1.2 & top.table$adj.P.Val<0.05))
length(which(top.table$logFC>1 & top.table$adj.P.Val<0.05))
pos.table <- which(top.table$logFC>1 & top.table$adj.P.Val<0.05) #Posicion de los genes buenos?
genesexpresados <- rnaseq[pos.table,]
View(genesexpresados)
View(genesexpresados)
genesexpresados <- rnaseq[pos.table,]
Data2 <-Data[colnames(genesexpresados),rownames(genesexpresados)]
genesexpresados <- rnaseq[pos.table,]
Data2 <-Data[colnames(genesexpresados),]
genesexpresados <- rnaseq[pos.table,]
sampleNames(genesexpresados)
genesexpresados <- rnaseq[pos.table,]
colnames(genesexpresados)
genesexpresados <- rnaseq[pos.table,]
Data2<-cbind(Data,colnames(genesexpresados))
View(Data2)
Data2<-Data
genesexpresados <- rnaseq[pos.table,]
Data2<-Data
for(i in rownames(genesexpresados)){
Data2<-cbind(Data2,i=genesexpresados[,i])
}
rownames(genesexpresados)
genesexpresados <- rnaseq[pos.table,]
rownames(genesexpresados)
genesexpresados
Data2<-Data
for(i in rownames(genesexpresados)){
print(i)
#Data2<-cbind(Data2,i=genesexpresados[,i])
}
genesexpresados <- rnaseq[pos.table,]
#rownames(genesexpresados)
#genesexpresados
Data2<-Data
for(i in rownames(genesexpresados)){
print(i)
#Data2<-cbind(Data2,i=genesexpresados[,i])
}
#rownames(genesexpresados)
#genesexpresados
genesexpresados[,"AACSL"]
length(rownames(genesexpresados))
genesexpresados <- rnaseq[pos.table,]
length(rownames(genesexpresados))
Data2<-Data
for(i in length(rownames(genesexpresados))){
Data2<-cbind(Data2,i=genesexpresados[,i])
}
genesexpresados[,i]
genesexpresados[,1]
genesexpresados[1,]
genesexpresados[1,]
genesexpresados[,1]
genesexpresados[1],]
length(rownames(genesexpresados))
genesexpresados <- rnaseq[pos.table,]
length(rownames(genesexpresados))
Data2<-Data
for(i in length(rownames(genesexpresados))){
Data2<-cbind(Data2,genesexpresados$i=genesexpresados[i,])
genesexpresados <- rnaseq[pos.table,]
length(rownames(genesexpresados))
Data2<-Data
for(i in length(rownames(genesexpresados))){
Data2<-cbind(Data2,Gen=genesexpresados[i,])
}
View(Data2)
filas<-rownames(genesexpresados)
filas[i]
genesexpresados <- rnaseq[pos.table,]
length(rownames(genesexpresados))
filas<-rownames(genesexpresados)
filas[i]
Data2<-Data
for(i in length(filas)){
Data2<-cbind(Data2,filas[i]=genesexpresados[i,])
filas[1]
genesexpresados <- rnaseq[pos.table,]
length(rownames(genesexpresados))
filas<-rownames(genesexpresados)
Data2<-Data
for(i in length(filas)){
Data2<-cbind(Data2,filas[i]=genesexpresados[i,])
Data2<-cbind(Data2,filas[1]=genesexpresados[1,]
filas[1]
Data2<-cbind(Data2,AACSL=genesexpresados[1,])
Data2<-Data
str(filas[1])
filas[1]
filas[1]
Data2<-cbind(Data2,"AACSL"=genesexpresados[1,])
Data2<-cbind(Data2,"AACSL"=genesexpresados[1,])
Data2<-cbind(Data2,"AACSL"=genesexpresados[1,])
View(Data2)
Data2<-Data
Data2<-cbind(Data2,fila[1]=genesexpresados[1,])
Data2<-cbind(Data2,filas[1]=genesexpresados[1,])
str
fila
fila<-filas[1]
fila
Data2<-Data
genesexpresados <- rnaseq[pos.table,]
length(rownames(genesexpresados))
filas<-rownames(genesexpresados)
Data2<-Data
for(i in length(filas)){
fila<-filas[i]
Data2<-cbind(Data2,fila=genesexpresados[i,])
}
View(Data2)
source("C:/Users/alepa/OneDrive/Escritorio/Universidad/4.Cuarto año/Biología de sistemas/Trabajo investigacion/Proyecto_Biologia_de_Sistemas/code/analisis_comunidades_grafo.R")
setwd("C:/Users/alepa/OneDrive/Escritorio/Universidad/4.Cuarto año/Biología de sistemas/Trabajo investigacion/Proyecto_Biologia_de_Sistemas/code")
library(igraph)
library(STRINGdb)
library(linkcomm)
library(clusterProfiler)
library(org.Hs.eg.db)
library(xtable)
## Limpiar terminal de R
cat("\014")
## Borrar variables de R
rm(list=ls())
nodes <- read.table("./string_node_degrees.tsv", sep = '\t',header = TRUE, as.is=T)
links <- read.table("./string_interactions.tsv", sep = '\t',header = TRUE, as.is=T)
##### Grafos con iGraph ####
## Crea un nuevo grafo a partir de los nodos y de las aristas proporcionadas (La red será dirigida)
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
lo <- layout_with_kk(net) # Creamos la disposición (layout) de los nodos
lo <- norm_coords(lo, ymin=-1, ymax=1, xmin=-1, xmax=1)
## Representa graficamente
pdf(file="../results/grafos_de_genes.pdf")
plot(net, edge.arrow.size=0.2, edge.curved=0.1, vertex.size=15, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
## Detección de comunidades por clustering ##
community <- cluster_edge_betweenness(net)
dendPlot(community)
pdf(file="../results/comunidades_por_clustering.pdf")
plot(community, net, edge.arrow.size=0.05, edge.curved=0.1, vertex.size=13, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
length(community)
membership(community)
## Detección de comunidades mediante optimización voraz ##
cfg <- cluster_fast_greedy(as.undirected(net))
dendPlot(cfg)
pdf(file="../results/comunidades_por_voraz.pdf")
plot(cfg, as.undirected(net), vertex.size=13, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
length(cfg)
membership(cfg)
#### NetworkPropagation de la red ####
string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="" )
string.network <- string_db$get_graph()
hits <- nodes$X9606.ENSP00000442954 # Nos quedamos con los String_ID de nuestro conjunto de genes
hits.network <- string_db$get_subnetwork(hits) # Creamos una network usando StringDb
first.neigh <- (neighbors(graph = string.network, v = V(hits.network)$name, mode = "all"))$name # Encontramos una serie de nodos vecinos
hits.network <- string_db$get_subnetwork(unique(c(V(hits.network)$name, first.neigh))) # Unimos la red de nodos originales con la red de vecinos
DFNetwork <- igraph::as_data_frame(hits.network)
## Analisis por linkcomm ##
pdf(file="../results/dendograma_por_linkcomm.pdf")
DC_lc <- getLinkCommunities(DFNetwork,hcmethod = "single") #Comunidades por LinkComm
dev.off()
pdf(file="../results/comunidades_por_linkcomm.pdf")
plot(DC_lc,
type = "graph",
vsize = 20,
vshape = "circle",
vlabel = FALSE,
layout = layout.fruchterman.reingold)
dev.off()
max(DC_lc$numclusters)
pdf(file="../results/barplot.pdf")
barplot(DC_lc$clustsize)
dev.off()
###Analisis de nuestra comunidad de genes originales###
Nodes<-gsub("9606.","",hits) # Procesamos su formato string
genes = bitr(Nodes, fromType="ENSEMBLPROT", toType="ENTREZID", OrgDb="org.Hs.eg.db") # Los pasamos a tipo ENTREZID
genes$ENTREZID=as.numeric(genes$ENTREZID) # Pasamos estos ENTREZID a numérico
ego <- enrichGO(gene          = genes$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = "CC",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
head(ego)
df_enrich = as.data.frame(ego@result)
df_enrich$qvalue = NULL
rownames(df_enrich) = NULL
print(xtable(df_enrich, type = "latex"), file = "../results/Tabla_Encriquecimiento_Funcional_Genes_Inciales.tex") # Se guardara en el file especificado
## Funcion para traducir a ENTREZID los genes de una comunidad dada
Muestra <- function(Clustnumber){
Nodes <- getNodesIn(DC_lc,clusterids = c(Clustnumber)) # Obtenemos los genes de la comunidad seleccionada
Nodes<-gsub("9606.","",Nodes) # Procesamos su formato string
genes = bitr(Nodes, fromType="ENSEMBLPROT", toType="ENTREZID", OrgDb="org.Hs.eg.db") # Los pasamos a tipo ENTREZID
genes$ENTREZID=as.numeric(genes$ENTREZID) # Pasamos estos ENTREZID a numérico
return(genes)
}
# Enriquecimiento funcional comunidad
Comm <- Muestra(33) # Id de la comunidad del cluster que se quiera estudiar
ego <- enrichGO(gene          = Comm$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = "CC",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
head(ego)
# A continuación se procede a guardar toda la tabla en un formato legible por latex
df_enrich = as.data.frame(ego@result)
df_enrich$qvalue = NULL
rownames(df_enrich) = NULL
df_enrich2 <- df_enrich
df_enrich3 <- df_enrich
df_enrich$BgRatio = NULL
df_enrich$pvalue = NULL
df_enrich$p.adjust = NULL
df_enrich$geneID = NULL
df_enrich$Count = NULL
df_enrich2$Description = NULL
df_enrich2$GeneRatio = NULL
df_enrich2$geneID = NULL
df_enrich3$Description = NULL
df_enrich3$GeneRatio = NULL
df_enrich3$BgRatio = NULL
df_enrich3$pvalue = NULL
df_enrich3$p.adjust = NULL
df_enrich3$Count = NULL
print(xtable(df_enrich, type = "latex"), file = "../results/Tabla_Encriquecimiento_Funcional_parte1.tex") # Se guardara en el file especificado
print(xtable(df_enrich2, type = "latex"), file = "../results/Tabla_Encriquecimiento_Funcionalparte2.tex") # Se guardara en el file especificado
print(xtable(df_enrich3, type = "latex"), file = "../results/Tabla_Encriquecimiento_Funcionalparte3.tex") # Se guardara en el file especificado
suppressMessages(library(igraph))
suppressMessages(library(STRINGdb))
suppressMessages(library(linkcomm))
suppressMessages(library(clusterProfiler))
suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(xtable))
## Limpiar terminal de R ##
cat("\014")
## Borrar variables de R ##
rm(list=ls())
nodes <- read.table("./string_node_degrees.tsv", sep = '\t',header = TRUE, as.is=T)
links <- read.table("./string_interactions.tsv", sep = '\t',header = TRUE, as.is=T)
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
lo <- layout_with_kk(net) # Creamos la disposición (layout) de los nodos
lo <- norm_coords(lo, ymin=-1, ymax=1, xmin=-1, xmax=1)
## Representa graficamente ##
pdf(file="../results/Red_de_genes_Original.pdf")
## Detección de comunidades por clustering ##
community <- cluster_edge_betweenness(net)
dendPlot(community)
pdf(file="../results/comunidades_por_clustering.pdf")
plot(community, net, edge.arrow.size=0.05, edge.curved=0.1, vertex.size=13, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
length(community)
membership(community)
cfg <- cluster_fast_greedy(as.undirected(net))
dendPlot(cfg)
pdf(file="../results/comunidades_por_voraz.pdf")
plot(cfg, as.undirected(net), vertex.size=13, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
length(cfg)
membership(cfg)
#### NetworkPropagation de la red ####
string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="" )
View(nodes)
View(nodes)
pdf(file="../results/dendograma_por_linkcomm.pdf")
DC_lc <- getLinkCommunities(DFNetwork,hcmethod = "single") # Comunidades por LinkComm
dev.off()
DC_lc <- getLinkCommunities(DFNetwork,hcmethod = "single") # Comunidades por LinkComm
.libPaths(paste0(Sys.getenv("R_LIBS_USER"),"/discalculia"))  # add to the path
suppressMessages(library(igraph))
suppressMessages(library(STRINGdb))
suppressMessages(library(linkcomm))
suppressMessages(library(clusterProfiler))
suppressMessages(library(org.Hs.eg.db))
suppressMessages(library(xtable))
## Limpiar terminal de R ##
cat("\014")
## Borrar variables de R ##
rm(list=ls())
nodes <- read.table("./string_node_degrees.tsv", sep = '\t',header = TRUE, as.is=T)
links <- read.table("./string_interactions.tsv", sep = '\t',header = TRUE, as.is=T)
##### Grafos con iGraph ####
## Crea un nuevo grafo a partir de los nodos y de las aristas proporcionadas (La red será dirigida) ##
net <- graph_from_data_frame(d=links, vertices=nodes, directed=T)
lo <- layout_with_kk(net) # Creamos la disposición (layout) de los nodos
lo <- norm_coords(lo, ymin=-1, ymax=1, xmin=-1, xmax=1)
## Representa graficamente ##
pdf(file="../results/Red_de_genes_Original.pdf")
plot(net, edge.arrow.size=0.2, edge.curved=0.1, vertex.size=15, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
## Detección de comunidades por clustering ##
community <- cluster_edge_betweenness(net)
dendPlot(community)
pdf(file="../results/comunidades_por_clustering.pdf")
plot(community, net, edge.arrow.size=0.05, edge.curved=0.1, vertex.size=13, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
length(community)
membership(community)
## Detección de comunidades mediante optimización voraz ##
cfg <- cluster_fast_greedy(as.undirected(net))
dendPlot(cfg)
pdf(file="../results/comunidades_por_voraz.pdf")
plot(cfg, as.undirected(net), vertex.size=13, vertex.color="white", vertex.frame.color="black", vertex.label.color="black",vertex.label.cex=0.4, layout=lo)
dev.off()
length(cfg)
membership(cfg)
#### NetworkPropagation de la red ####
string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="" )
string.network <- string_db$get_graph() # Obtenemos una red de nodos de string del organismo Homo Sapiens
hits <- nodes$identifier # Nos quedamos con los identificadores de String de nuestro conjunto de genes
hits.network <- string_db$get_subnetwork(hits)  # Creamos una network de nuestros nodos usando StringDb
first.neigh <- (neighbors(graph = string.network, v = V(hits.network)$name, mode = "all"))$name   # Encontramos una serie de nodos vecinos
hits.network <- string_db$get_subnetwork(unique(c(V(hits.network)$name, first.neigh))) # Unimos la red de nodos originales con la red de vecinos
DFNetwork <- igraph::as_data_frame(hits.network)
## Analisis por linkcomm ##
pdf(file="../results/dendograma_por_linkcomm.pdf")
DC_lc <- getLinkCommunities(DFNetwork,hcmethod = "single") # Comunidades por LinkComm
dev.off()
pdf(file="../results/comunidades_por_linkcomm.pdf")
plot(DC_lc,
type = "graph",
vsize = 20,
vshape = "circle",
vlabel = FALSE,
layout = layout.fruchterman.reingold)
dev.off()
max(DC_lc$numclusters)
pdf(file="../results/comunidades_por_linkcomm_barplot.pdf")
barplot(DC_lc$clustsize, xlab="Id comunity", ylab="Size of cluster") # Tamanos de los diferentes clusters
dev.off()
#### Analisis de nuestra comunidad de genes originales ####
## Funcion para traducir a ENTREZID los genes de una comunidad dada ##
ID_to_EntrezID <- function(Clustnumber){
Nodes <- getNodesIn(DC_lc,clusterids = c(Clustnumber))           # Obtenemos los genes de la comunidad seleccionada
Nodes<-gsub("9606.","",Nodes)                                                        # Procesamos su formato string
genes = bitr(Nodes, fromType="ENSEMBLPROT", toType="ENTREZID", OrgDb="org.Hs.eg.db") # Los pasamos a tipo ENTREZID
genes$ENTREZID=as.numeric(genes$ENTREZID)                                            # Pasamos estos ENTREZID a numérico
return(genes)
}
### Analisis de nuestra comunidad de genes originales ###
originales <- gsub("9606.","",nodes$identifier)
originales <- bitr(originales, fromType="ENSEMBLPROT", toType="ENTREZID", OrgDb="org.Hs.eg.db") # Los pasamos a tipo ENTREZID
originales <- as.numeric(originales$ENTREZID)
ego <- enrichGO(gene          = originales,
OrgDb         = org.Hs.eg.db,
ont           = "CC",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
head(ego)
# A continuación se procede a guardar toda la tabla en un formato legible por latex
df_enrich = as.data.frame(ego@result)
df_enrich$qvalue = NULL
rownames(df_enrich) = NULL
df_enrich2 <- df_enrich
df_enrich$BgRatio = NULL
df_enrich$pvalue = NULL
df_enrich$p.adjust = NULL
df_enrich$geneID = NULL
df_enrich$Count = NULL
df_enrich2$Description = NULL
df_enrich2$GeneRatio = NULL
dir.create(file.path("../results/", "/comunidad_Original"))
print(xtable(df_enrich, type = "latex"), file = "../results/comunidad_Original/Tabla_Encriquecimiento_Funcional_parte1.tex") # Se guardara en el file especificado
print(xtable(df_enrich2, type = "latex"), file = "../results/comunidad_Original/Tabla_Encriquecimiento_Funcional_parte2.tex") # Se guardara en el file especificado
## Enriquecimiento funcional comunidad 64 ##
Comm <- ID_to_EntrezID(1) # Id de la comunidad del cluster que se quiera estudiar
ego <- enrichGO(gene          = Comm$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = "CC",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
head(ego)
# Guardamos las tablas en un formato legible por latex #
df_enrich = as.data.frame(ego@result)
df_enrich$qvalue = NULL
rownames(df_enrich) = NULL
df_enrich2 <- df_enrich
df_enrich3 <- df_enrich
df_enrich$BgRatio = NULL
df_enrich$pvalue = NULL
df_enrich$p.adjust = NULL
df_enrich$geneID = NULL
df_enrich$Count = NULL
df_enrich2$Description = NULL
df_enrich2$GeneRatio = NULL
df_enrich2$geneID = NULL
df_enrich3$Description = NULL
df_enrich3$GeneRatio = NULL
df_enrich3$BgRatio = NULL
df_enrich3$pvalue = NULL
df_enrich3$p.adjust = NULL
df_enrich3$Count = NULL
dir.create(file.path("../results/", "/comunidad_64"))
print(xtable(df_enrich, type = "latex"), file = "../results/comunidad_64/Tabla_Encriquecimiento_Funcional_parte1.tex") # Se guardara en el archivo especificado
print(xtable(df_enrich2, type = "latex"), file = "../results/comunidad_64/Tabla_Encriquecimiento_Funcional_parte2.tex") # Se guardara en el archivo especificado
print(xtable(df_enrich3, type = "latex"), file = "../results/comunidad_64/Tabla_Encriquecimiento_Funcional_parte3.tex") # Se guardara en el archivo especificado
## Enriquecimiento funcional comunidad 70 ##
Comm <- ID_to_EntrezID(70) # Id de la comunidad del cluster que se quiera estudiar
ego <- enrichGO(gene          = Comm$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = "CC",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
head(ego)
# Guardamos las tablas en un formato legible por latex #
df_enrich = as.data.frame(ego@result)
df_enrich$qvalue = NULL
rownames(df_enrich) = NULL
df_enrich2 <- df_enrich
df_enrich3 <- df_enrich
df_enrich$BgRatio = NULL
df_enrich$pvalue = NULL
df_enrich$p.adjust = NULL
df_enrich$geneID = NULL
df_enrich$Count = NULL
df_enrich2$Description = NULL
df_enrich2$GeneRatio = NULL
df_enrich2$geneID = NULL
df_enrich3$Description = NULL
df_enrich3$GeneRatio = NULL
df_enrich3$BgRatio = NULL
df_enrich3$pvalue = NULL
df_enrich3$p.adjust = NULL
df_enrich3$Count = NULL
dir.create(file.path("../results/", "/comunidad_70"))
print(xtable(df_enrich, type = "latex"), file = "../results/comunidad_70/Tabla_Encriquecimiento_Funcional_parte1.tex") # Se guardara en el archivo especificado
print(xtable(df_enrich2, type = "latex"), file = "../results/comunidad_70/Tabla_Encriquecimiento_Funcional_parte2.tex") # Se guardara en el archivo especificado
print(xtable(df_enrich3, type = "latex"), file = "../results/comunidad_70/Tabla_Encriquecimiento_Funcional_parte3.tex") # Se guardara en el archivo especificado
## Enriquecimiento funcional comunidad 33 ##
Comm <- ID_to_EntrezID(33) # Id de la comunidad del cluster que se quiera estudiar
ego <- enrichGO(gene          = Comm$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = "CC",
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
head(ego)
# Guardamos las tablas en un formato legible por latex #
df_enrich = as.data.frame(ego@result)
df_enrich$qvalue = NULL
rownames(df_enrich) = NULL
df_enrich2 <- df_enrich
df_enrich3 <- df_enrich
df_enrich$BgRatio = NULL
df_enrich$pvalue = NULL
df_enrich$p.adjust = NULL
df_enrich$geneID = NULL
df_enrich$Count = NULL
df_enrich2$Description = NULL
df_enrich2$GeneRatio = NULL
df_enrich2$geneID = NULL
df_enrich3$Description = NULL
df_enrich3$GeneRatio = NULL
df_enrich3$BgRatio = NULL
df_enrich3$pvalue = NULL
df_enrich3$p.adjust = NULL
df_enrich3$Count = NULL
dir.create(file.path("../results/", "/comunidad_33"))
print(xtable(df_enrich, type = "latex"), file = "../results/comunidad_33/Tabla_Encriquecimiento_Funcional_parte1.tex") # Se guardara en el archivo especificado
print(xtable(df_enrich2, type = "latex"), file = "../results/comunidad_33/Tabla_Encriquecimiento_Funcional_parte2.tex") # Se guardara en el archivo especificado
print(xtable(df_enrich3, type = "latex"), file = "../results/comunidad_33/Tabla_Encriquecimiento_Funcional_parte3.tex") # Se guardara en el archivo especificado
originales <- gsub("9606.","",nodes$identifier)
originales <- bitr(originales, fromType="ENSEMBLPROT", toType="ENTREZID", OrgDb="org.Hs.eg.db") # Los pasamos a tipo ENTREZID
originales
originales <- gsub("9606.","",nodes$identifier)
originales
save(originales)
save(originales,file="genes_originales_list.txt")
dir.create(paste0(Sys.getenv("R_LIBS_USER"),"/discalculia"), recursive = TRUE)  # create personal library
.libPaths(paste0(Sys.getenv("R_LIBS_USER"),"/discalculia"))  # add to the path
path_discalculia <- paste0(Sys.getenv("R_LIBS_USER"),"/discalculia")
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager", lib = path_discalculia)
if (!require("igraph", quietly = TRUE))
install.packages("igraph", lib = path_discalculia)
if (!require("xtable", quietly = TRUE))
install.packages("xtable", lib = path_discalculia)
if (!require("STRINGdb", quietly = TRUE))
BiocManager::install("STRINGdb", lib = path_discalculia)
if (!require("linkcomm", quietly = TRUE))
BiocManager::install("linkcomm", lib = path_discalculia)
if (!require("org.Hs.eg.db", quietly = TRUE))
BiocManager::install("org.Hs.eg.db", lib = path_discalculia)
if (!require("clusterProfiler", quietly = TRUE))
BiocManager::install("clusterProfiler", lib = path_discalculia)
